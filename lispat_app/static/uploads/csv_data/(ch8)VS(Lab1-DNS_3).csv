Document Type,Document,Text
standard,(Lab1-DNS_3),"  1   CSCI3761      Lab #1                   Spring 2019 Due: February, 27 (Wednesday), 2019 Max points: 30 points  Objective  1. Learn how to use packet sniffing tool, Wireshark 2. Learn the main protocol of DNS (Domain Name Services)    Note: This lab is adapted from DNS WireShark Lab, “Computer Networking: A Top-Down Approach”, 7th ed, J.F. Kurose and K.W. Ross.  Required software tool  1. Packet Sniffer  The purpose of lab assignments is to show how we can get a deeper understanding of the networking concepts by capturing and analyzing the packets sent and received from our host. One way to do so is to use a packet sniffer. A packet sniffer is a piece of soft- ware that should be running in parallel with the application whose packets needed to be analyzed. However, before running a packet sniffer, we need to interpret the term packet. As we discussed in Chapter 1 of the textbook, communication via the Internet is done using a five-layer suite. We can analyze the packets at four layers: application, transport, network, and data-link. There is no packet exchange at the physical layer; communication at this layer is done using bits.  In an outgoing situation, a packet created at any upper-layer is encapsulated in a frame (at the data-link layer); in an incoming situation, a packet intended for any layer is decapsulated from the received frame. This means we need to capture only outgoing or incoming frames; a packet-sniffer software can extract the packets at any layer desired to be analyzed from these frames. For this reason, a packet-sniffer software is normally has two components: a packet-capturer and a packet-analyzer. The packet-capturer captures a copy of all outgoing and incoming frames (at the data-link layer) and passes them to the packet-analyzer. The packet- analyzer can then extract different headers and the ultimate message for analysis.  2. Wireshark  In this and other lab assignments, we use a packet-sniffer called Wireshark. Wireshark (formerly known as ETHEREAL) is a free packet sniffer/analyzer which is available for  2  both UNIX-like (Unix, Linux, Mac OS X, BSD, and Solaris) and Windows operating systems. It captures packets from a network interface and displays them with detailed protocol information. Wireshark, however, is a passive analyzer. It only captures packets without manipulate them; it neither sends packets to the network nor does other active operations. Wireshark is not an intrusion-detection tool either. It does not give warning about any network intrusion. It, nevertheless, can help network administrators to figure out what is going on inside a network and to troubleshoot network problems. In addition of being an indispensable tool for network administrators, Wire- shark is a valuable tool for protocol developers, who may use it to debug protocol implementations. It is also a great educational tool for computer-network students who can use it to see details of protocol operations in real time.  2.1 Downloading and Installing To download the Wireshark software, connect to the Internet using the website:  http://www.wireshark.org/download.html  After the downloading is complete, install the software on your computer. If you have any problem in downloading or installing, you can consult the following site for more information:  http://wiki.wireshark.org/CaptureSetup 2.2 Main Window  The Wireshark main window is similar to other GUI tools as shown in Figure 2.1. The Wireshark window is made of seven sections: title bar, menu bar, filter bar, packet list pane, packet detail pane, packet byte pane, and status bar. We briefly discuss the functionality of each section below:  Title Bar The title bar (like the one in any GUI) shows the title of the window, the closing, maximizing, and minimizing icons.  Menu Bar The menu bar is made of several pulldown menus and tool bars used in most GUIs. We will using some of these menus in our lab assignments. We can use the File menu to perform some actions on the file itself such as saving and printing. The Capture menu is used to start and capturing frames. The View menu is useful to show or hide some of the sections in the window.     3  Filter Bar  The filter bar allows us to display packet we are interested in while hiding the rest. As we see later in this document, when we start capturing frames, Wireshark captures and analyze any outgoing and incoming frame no matter what is the source or sink proto- col. Sometimes, this is not what we want. We may want to limit the analysis to a specific source or sink protocol. For example, we may want to analyze only packets sent or receive by the HTTP protocol at the application layer or the ARP protocol at the net- work layer. This is called filtering in the parlance of packet sniffing. After packets have been captured, we can type the name of the protocol in lowercase and click Apply.   Figure 2.1   Main window of Wireshark                                                                                                                                                         Packet byte pane Status Bar Packet list pane Packet detail pane   Filter bar Menu toolbar Title bar  4    Packet List Pane The packet list pane displays a one-line summary for each captured packet (actually frame). The summary includes the packet (frame) number (added by the Wireshark and not part of the packet), the time when the packet was captured, the source and destination IP addresses of the packet (at the network layer), the packet source or sink proto- col, and the additional information about the packet contents. In other words, this pane shows the captured frames that will be passed for analyzing to the packet analyzer.  Packet Detail Pane The packet detail pane shows the detailed analysis for each frame (Figure 2.2).  The information is limited to one frame, which means we need to select one of the frames in the packet list pane for analysis. This can be done by clicking on the corresponding frame in the packet list pane. Clicking on any frame in the packet list pane highlights the frame and shows the details of the frame in the packet details pane. Information exhibited in this pane for each frame is made of a tree structure. However, each top branch of the tree is shown as one line as it is common in GUI trees. We can expand the branch (to see subbranches) by clicking on the plus box at the leftmost part of the line, which changes the plus sign to a minus sign; the branch can be collapsed again, which changes the minus sign to the plus sign. Note that the analyzer first shows a general information at the data-link layer (frame). It then displays the information contained in each header from the data-link layer (H2) up to the source or sink protocol. It finally shows the whole message at the source or sink layer. Figure 2.2 shows an example of a packet details pane when the frame is expanded. It shows some general information and names of all protocols used in the frame (intermediate and source or sink).             5                                    Figure 2.2   Packet detail pane     Packet byte pane The packet byte pane shows the entire current frame (selected in the packet list pane) in hexdump format (hexadecimal view of data) and ASCII format. The number in the left field shows the offset in the packet data; the hexdump of the packet is shown in the middle field; the corresponding ASCII characters are shown in the right field. If we need the byte (or ASCII equivalent) of any line in the packet detail pane, we can click on the line in the packet detail pane and the byte contents will be highlighted. Figure 2.3 shows an example of a packet byte pane. It shows all the bytes in the frame, but we can select the bytes in any protocol header by highlighting it in the packet detail pane section.           6                         Figure 2.3   Packet byte pane       Status Bar The last section of the window (at the bottom) is the status bar which shows the current protocol, the total number of packets captured, and so on.  2.3    Working With Wireshark  When we work with Wireshark in this and other labs, there are some actions that we need to repeat over and over. We mention the details of some of this action to avoid re- mentioning them.  Start Capturing To begin capturing, select the Capture from the pull down menu and click Options to open the Wireshark capture options dialog box (Figure 2.5).    7     Figure 2.5   Caption options dialog box                           There are several steps that you need to follow before you start capturing:  ■   You normally will use the default values in the capture options dialog box, but there are some options that you may need to override the default. In particular, you may want to uncheck “Hide capture info dialog.” and open capture information window (Figure 2.6). ■   The network interfaces are shown in the Interface drop-down list at the top of the dialog box. Select the network interface (or use the default interface chosen by Wireshark). If the IP address in the dialog box is unknown, you must select a different interface; otherwise, the Wireshark will not capture any packet    8         Figure 2.6   Capture information dialog      . ■   After the above two steps, click Start. Wireshark starts to captures packets that are exchanged between your computer and the network. If, after a minute, Wireshark does not capture any packet, there must be a problem; check for possible reason and troubleshooting.  Stop Capturing Whenever you feel you have captured all the packets (frames) that you need to do your lab report, you can stop capturing. To do so, you need to use the Capture pulldown menu and click Stop. Wireshark stops capturing the frames  Saving the Captured File After you have stopped capturing, you may want to save the captured file for future use.  9  2.4  Incoming and Outgoing Frames  When we see the list of the captured frames, we often wonder which frames are the incoming and which ones are outgoing. This can be found by looking at the frame in packet list pane. The packet list pane shows the source and destination addresses of the frame (generated and inserted at the network layer). If the source address is the address of the host you are working with (shown on the Capture window when you start capturing), the frame is the outgoing frame; if the destination address is the address of your host, and the frame is the incoming frame.  2.5 Lab-Report Sheets To make the report of your observation in each chapter easier and consistent, we have created lab report sheets for each lab assignment. Each chapter has as many lab report sheets as the number of lab assignments for that chapter. Each lab report sheet has been prepared as a Word documents to let the student fill up and turn in.  2.6 Printing the Captured Information As a supporting document for each lab assignment, you need to turn in a printout of the captured information. You can do this by selecting the packet and expanding it in the packet detailed pane, selecting Print from the File menu, selecting the necessary printing options in the Wireshark print window, and finally clicking the Print button.                    10  3. LAB1 : DNS  + Wireshark The lab assignment for this chapter is a warm-up testing of the Wireshark software. In this lab, we retrieve a web page and then, using Wireshark, capture packets.  There are several network administration tools for Microsoft Windows and UNIX-like operating systems that are useful for network troubleshooting as well as for educational purposes. Among these tools are the following: ■ dig (Domain Information Groper) is used for querying DNS servers. This utility replaces older tools such as nslookup. ■ ipconfig (Internet Protocol Configuration) for Windows or ifconfig (Interface Configuration) for UNIX-like operating systems is used to configure, control, and query TCP/IP network interface parameters.  3.1 Assignment This lab is made of three parts. In Part I, we use the nslookup. In Part II, we use ipcon- fig utility. Finally, in Part III, we use Wireshark to find more information about the packets exchanged by the DNS protocol. Pick an educational institute outside of the state of Colorado, and use its Hostname or IP address when you run “dig” using both CLI based and Web based.  3.1 nslookup In this lab, we’ll make extensive use of the nslookup tool, which is available in most Linux/Unix and Microsoft platforms today. To run nslookup in Linux/Unix, you just type the nslookup command on the command line. To run it in Windows, open the Command Prompt and run nslookup on the command line.  In it is most basic operation, nslookup tool allows the host running the tool to query any specified DNS server for a DNS record. The queried DNS server can be a root DNS server, a top-level-domain DNS server, an authoritative DNS server, or an intermediate DNS server (see the textbook for definitions of these terms). To accomplish this task, nslookup sends a DNS query to the specified DNS server, receives a DNS reply from that same DNS server, and displays the result.   11   The above screenshot shows the results of three independent nslookup commands (displayed in the Windows Command Prompt). In this example, the client host is located on the campus of Polytechnic University in Brooklyn, where the default local DNS server is dns-prime.poly.edu. When running nslookup, if no DNS server is specified, then nslookup sends the query to the default DNS server, which in this case is dns-prime.poly.edu. Consider the first command: nslookup www.mit.edu In words, this command is saying “please send me the IP address for the host www.mit.edu”. As shown in the screenshot, the response from this command provides two pieces of information: (1) the name and IP address of the DNS server that provides the answer; and (2) the answer itself, which is the host name and IP address of www.mit.edu. Although the response came from the local DNS server at Polytechnic University, it is quite possible that this local DNS server iteratively    12  contacted several other DNS servers to get the answer, as described in Section 4.17 of the textbook.  Now consider the second command: nslookup –type=NS mit.edu In this example, we have provided the option “-type=NS” and the domain “mit.edu”. This causes nslookup to send a query for a type-NS record to the default local DNS server. In words, the query is saying, “please send me the host names of the authoritative DNS for mit.edu”. (When the –type option is not used, nslookup uses the default, which is to query for type A records.) The answer, displayed in the above screenshot, first indicates the DNS server that is providing the answer (which is the default local DNS server) along with three MIT nameservers. Each of these servers is indeed an authoritative DNS server for the hosts on the MIT campus. However, nslookup also indicates that the answer is “non-authoritative,” meaning that this answer came from the cache of some server rather than from an authoritative MIT DNS server. Finally, the answer also includes the IP addresses of the authoritative DNS servers at MIT. (Even though the type-NS query generated by nslookup did not explicitly ask for the IP addresses, the local DNS server returned these “for free” and nslookup displays the result.) Now finally consider the third command: nslookup www.snu.ac.kr google-piblic-dns-a.google.com In this example, we indicate that we want to the query sent to the DNS server bitsy.mit.edu rather than to the default DNS server (dns-prime.poly.edu). Thus, the query and reply transaction takes place directly between our querying host and bitsy.mit.edu. In this example, the DNS server bitsy.mit.edu provides the IP address of the host www.aiit.or.kr, which is a web server at the Advanced Institute of Information Technology (in Korea).  Now that we have gone through a few illustrative examples, you are perhaps wondering about the general syntax of nslookup commands. The syntax is:  13  nslookup –option1 –option2 host-to-find dns-server In general, nslookup can be run with zero, one, two or more options. And as we have seen in the above examples, the dns-server is optional as well; if it is not supplied, the query is sent to the default local DNS server.  Now that we have provided an overview of nslookup, it is time for you to test drive it yourself.  Questions (Do the following (and write down the results)):  1. Run nslookup to obtain the IP address of a Web server in Asia. What is the IP address of that server? 2. Run nslookup to determine the authoritative DNS servers for a university in Europe. 3. Run nslookup so that one of the DNS servers obtained in Question 2 is queried for the mail servers for Yahoo! mail.   What is its IP address?  3.2  Using ipconfig  ipconfig (for Windows) and ifconfig (for Linux/Unix) are among the most useful little utilities in your host, especially for debugging network issues. Here we’ll only describe ipconfig, although the Linux/Unix ifconfig is very similar. ipconfig can be used to show your current TCP/IP information, including your address, DNS server addresses, adapter type and so on. For example, if you all this information about your host simply by entering  ipconfig \all into the Command Prompt, as shown in the following screenshot.    14   ipconfig is also very useful for managing the DNS information stored in your host. In Section 4.17 we learned that a host can cache DNS records it recently obtained. To see these cached records, after the prompt C:\> provide the following command: ipconfig /displaydns Each entry shows the remaining Time to Live (TTL) in seconds. To clear the cache, enter ipconfig /flushdns Flushing the DNS cache clears all entries and reloads the entries from the hosts file.    15  Tracing DNS with Wireshark Now that we are familiar with nslookup and ipconfig, we’re ready to get down to some serious business. Let’s first capture the DNS packets that are generated by ordinary Web-surfing activity. • Use ipconfig to empty the DNS cache in your host. • Open your browser and empty your browser cache. (With Internet Explorer, go to Tools menu and select Internet Options; then in the General tab select Delete Files.) • Open Wireshark and enter “ip.addr == your_IP_address” into the filter, where you obtain your_IP_address with ipconfig. This filter removes all packets that neither originate nor are destined to your host.  • Start packet capture in Wireshark. • With your browser, visit the Web page: http://www.ietf.org  • Stop packet capture.   Answer the following questions. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked.  Annotate the printout1 to explain your answer. To print a packet, use File->Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. Questions Using the result of running ipconfig, answer the following question in your lab report.  4. Locate the DNS query and response messages. Are then sent over UDP or TCP?  5. What is the destination port for the DNS query message? What is the source port of DNS response message?                                                            1 What do we mean by “annotate”?  If you hand in a paper copy, please highlight where in the printout you’ve found the answer and add some text (preferably with a colored pen) noting what you found in what you ‘ve highlight.  If you hand in an electronic copy, it would be great if you could also highlight and annotate.    16  6. To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same?  7. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? 8. Examine the DNS response message. How many “answers” are provided? What do each of these answers contain? 9. Consider the subsequent TCP SYN packet sent by your host. Does the destination  IP address of the SYN packet correspond to any of the IP addresses provided in the DNS response message? 10. This web page contains images. Before retrieving each image, does your host issue new DNS queries?                            17  3,.3 Using Wireshark to Capture DNS Packets  Now let’s play with nslookup. • Start packet capture.  • Do an nslookup on www.mit.edu • Stop packet capture.    You should get a trace that looks something like the following:  We see from the above screenshot that nslookup actually sent three DNS queries and    18  received three DNS responses. For the purpose of this assignment, in answering the following questions, ignore the first two sets of queries/responses, as they are specific to nslookup and are not normally generated by standard Internet applications. You should instead focus on the last query and response messages. Questions  11. What is the destination port for the DNS query message? What is the source port of DNS response message? 12. To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server? 13. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? 14. Examine the DNS response message. How many “answers” are provided? What do each of these answers contain? 15. Provide a screenshot.  Now repeat the previous experiment, but instead issue the command: nslookup –type=NS mit.edu Questions  16. To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server? 17. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? 18. Examine the DNS response message. What MIT nameservers does the response message provide? Does this response message also provide the IP addresses of the MIT namesers? 19. Provide a screenshot.    19  Now repeat the previous experiment, but instead issue the command: nslookup www.snu.ac.kr google-public-dns-a.google.com Answer the following questions: 20. To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server? If not, what does the IP address correspond to? 21. Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? 22. Examine the DNS response message. How many “answers” are provided? What does each of these answers contain? 23. Provide a screenshot.  4. Documents to Turn in  Turn in the following documents:  A hard copy of the Lab1-DNS report sheet that contains answered questions and the screen captures of all three parts for your answers.      "
submission,(ch8),"Chapter 8   Reliability and Channel CodingChapter 8This slide is adopted from LamiKaya& Douglas Comer1Topics Covered8.1  Introduction    8.2  The Three Main Sources of Transmission Errors    8.3  Effect of Transmission Errors on Data    8.4  Two Strategies for Handling Channel Errors    8.5  Block and ConvolutionalError Codes    8.6  An Example Block Error Code: Single Parity Checking    8.7  The Mathematics of Block Error Codes and (n, k) Notation    8.8  Hamming Distance: A Measure of a Code's Strength    8.9  The Hamming Distance Among Strings in a Codebook    8.10  The Tradeoff Between Error Detection and Overhead 8.11  Error Correction with Row and Column (RAC) Parity   8.12  The 16-Bit Checksum Used in the Internet      8.13  Cyclic Redundancy Codes (CRCs)    8.14  An Efficient Hardware Implementation of CRC    8.15  Automatic Repeat reQuest(ARQ) MechanismsChapter 828.1  Introduction    This chapter continues the discussion by examining errors that can occur during transmission and techniques that can be used to control errorsThe concepts presented here •are fundamental to computer networking•and are used in communication protocols at many layers of the stackChapter 83Interferenceelectromagnetic radiation emitted from devices such as electric motors and background cosmic radiation can cause noise that can disturb radio transmissions and signals traveling across wiresAttenuationAs a signal passes across a medium, the signal becomes weaker•signals on wires or optical fibers become weaker over long distances, just as a radio signal becomes weaker with distanceChapter 88.2  The Three Main Source of Transmission Errors   4DistortionAll physical systems distort signalsAs a pulse travels along an optical fiber, the pulse dispersesWires have properties of capacitanceand inductance•that block signals at some frequencies while admitting signals at other frequenciesPlacing a wire near a large metal object can change the set of frequencies that can pass through the wireMetal objects can block some frequencies of radio waves, while passing othersChapter 88.2  The Three Main Source of Transmission Errors   58.2  The Three Main Source of Transmission Errors   Shannon's Theorem suggests one way to reduce errors:increase the signal-to-noise ratio (either by increasing the signal or lowering noise if possible) where•Cis the effective limit on the channel capacity in bits per second•Bis the hardware bandwidth•S/Nis the  signal-to-noise ratio, the ratio of the average signal power divided by the average noise powerMechanisms like shieldedwiring can help lower noiseBut, Physical transmission system is always susceptible to errors•it may not be possible to change the signal-to-noise ratioChapter 868.2  The Three Main Source of Transmission Errors   Noise/interference cannot be eliminated completelyBut many transmission errors can be detectedIn some cases, errors can be correctedautomatically We will see that error detection adds overheadError handling is a tradeoff in which a system designer must decide whether a given error is likely to occur, and if so, what the consequences will beChapter 878.3  Effect of Transmission Errors on Data    Below table lists the three principal ways transmission errors affect dataChapter 8Type of ErrorDescriptionSingle Bit ErrorA single bitin a block of bits is changed and all other bits in the block are unchanged (often results from very short-duration interference)BurstErrorMultiple bits in a block of bits are changed (often results from longer-duration interference)Erasure (Ambiguity)The signalthat arrives at a receiver is ambiguous (does not clearly correspond to either a logical 1 or a logical 0 –can result from distortion or interference)88.3  Effect of Transmission Errors on Data    For a burst error, the burst size, orlength, is defined as the number of bits from the start of the corruption to the end of the corruptionFigure 8.2 illustrates the definitionChapter 898.4  Two Strategies for Handling Channel Errors    A variety of mathematical techniques have been developed that overcome errors during transmission and increase reliabilityKnown collectively as channel codingThe techniques can be divided into two broad categories:Forward Error Correction (FEC) mechanismsAutomatic Repeat reQuest(ARQ) mechanismsThe basic idea of FEC is straightforward: add additional information to data that allows a receiver toverify that data arrives correctly and to correct errors (if possible)Chapter 8108.4  Two Strategies for Handling Channel Errors Chapter 8118.4  Two Strategies for Handling Channel Errors    Basic error detection mechanisms allow a receiverto detect when an error has occurred; FEC (Forward Error Correction) mechanisms allow a receiver to determine exactly which bits have been changed and to compute correct valuesThe second approach to channel coding, known as an ARQ (Automatic Repeat reQuest),requires the cooperation of a sender;a sender and receiver exchange messagesto insure that all data arrives correctlyChapter 812AnFECcommunicationsystemaddsinformationatthe transmitterforerrorcorrectionofcorrupteddataatthe receiver.ATypicalErrorCorrectingCommunicationSystem.DataENCODEMODULATENoiseNoiseTRANSMITTERSECTIONINFORMATIONRECEIVERSECTIONDEMODULATEDECODEChapter 813ForwardErrorCorrection(FEC)Applications.Aspreviouslydiscussed,forwarderrorcorrectionisused atthereceivingendtodetecterrorsandcorrectforthem.SomeapplicationsincludeCDandDVDplayers,HDTV, Datastoragesystems,Wirelesscommunications,Satellite communications,andModemtechnologies.DesignershaveimplementedFECcircuitsinApplication SpecificIntegratedCircuits(ASICs),DigitalSignalProcessors (DSPs),andFieldProgrammableGateArrays(FPGAs).FECtechniquescanberealizedforbothBlockcodes andforConvolutionalcodesChapter 8148.5  Block and Convolutional Error Codes    The two types of FEC techniques satisfy separate needs:Block Error Codes•It divides the data to be sent into a set of blocks•It attaches extra information known asredundancy to each block•The encoding for a given block of bits depends only on the bits themselves, not on bits that were sent earlier•They are memory-less in the sense that the encoding mechanism does not carry state information from one block of data to the nextConvolutional Error Codes•It treats data as a series of bits, and computes a code over a continuous series•Thus, the code computed for a set of bits depends on the current input and some of the previous bits in the stream•Convolutional codes are said to be codes with memoryChapter 8158.6  An Example Block Error Code: Single Parity Checking    How can additional information be used to detect errors?consider a single parity checking (SPC) mechanismOne form of SPC defines a block to be an 8-bitunit of data (i.e., a single byte)•On the sending side, an encoder adds an extra bit, called a parity bit, to each byte before transmission•A receiver uses parity bit to check whether bits in the byte are correct•Before parity can be used, the sender and receiver must be configured for either even parity or odd parityFigure 8.4 lists examples of data bytes and the value of the parity bit that is sent when using even or odd parityChapter 8168.6  An Example Block Error Code: Single Parity Checking Chapter 8178.6  An Example Block Error Code: Single Parity Checking    SPC is a weak form of channel coding that can detect errorsbut cannot correct errorsAn even parity mechanism can only handle errors where an odd number of bits are changed•If one of the nine bits (including the parity bit) is changed during transmission, the receiver will declare that the incoming byte is invalid•However, if a burst error occurs in which two, four, six, or eightbits change value, the receiver will incorrectlyclassify the incoming byte as validChapter 818Example of Block Error CodeSingle Bit Parity:Detect single bit errorsTwo Dimensional Bit Parity (RAC):Detect and correctsingle bit errors0011Chapter 8198.7  The Mathematics of Block Error Codes and Notation    Mathematicallywe define the set of all possible messages to be a set of datawordsand define the set of all possible encoded versions to be a set of codewordsIf a datawordcontains kbits and r additional bits are added to form a codeword, we say that the result is an (n, k)encoding scheme where  n = k + rThe key to successful error detection lies in choosing a subset of the 2npossible combinations that are valid codewordsThe valid subset is known as a codebookChapter 8208.7 The Mathematics of Block Error Codes and NotationError DetectionExample •Let us assume that k = 2 and n = 3. The below table shows the list of data-words and code-words. Later, we will see how to derive a code-word from a data-word.DatawordCodewordDatawordCodeword000001010101011111101)If the receiver receives 011?Validcodeword and extract 012)If the receiver receives 111(the left most bit is corrupted)?Invalidcodeword and discard3)If the receiver receives 000? (the right two bits are corrupted)Validcodeword and extract 00 (detected ?)Assume the sender encodes the dataword “01” as “011” and send it to the receiverChapter 8218.7  The Mathematics of Block Error Codes and Notation    As an example, consider SPC(Single Parity Check)The set of datawordsconsists of any possible combination of 8-bits•Thus, k = 8 and there are 28or 256possible data words•The set of n = 9 bits, so there are 29or 512possibilities–However, only half of the 512 values form valid codewordsThink of the set of all possible n-bitvalues and the valid subset that forms the codebookIf an error occurs during transmission•one or more of the bits in a codeword will be changed, which will either produce another valid codeword or an invalid combinationFor the example discussed above•a change to a single bit of a valid codeword produces an invalid combination, but changing two bits produces another valid codewordChapter 8228.8 Hamming Distance: A Measure of a Code's Strength    No channel coding scheme is ideal!changing enough bits will always transform to a valid codewordWhat is the minimum number of bits of a valid codeword that must be changed to produce another valid codeword?To answer the question, engineers use a measure known as the  Hamming distance, named after a theorist at Bell Laboratories who was a pioneer in the field of information theory and channel codingGiven two strings of nbits each, the Hamming distance is defined as the number of differencesFigure 8.5 illustrates the definition ECC memory uses Hamming Codes Chapter 8238.8 Hamming Distance: A Measure of a Code's Strength Chapter 8248.8 Hamming DistanceHamming distance(d) of two bit strings = number of bit positions in which they differ.e.g.: d (000,011) = 2, (000 011) = 011 (two 1s)     d (10101,11110) = 3, (10101 11110) = 01011 (three 1s)000001111100101011110010codeworddmin= 2 = min distancen = 3 = dimensionality2n= 8 = number of nodesChapter 8258.8 Hamming Distance: A Measure of a Code's Strength    One way to compute the Hamming distance consists oftaking the exclusive or (xor) between two strings and counting the number of 1bits in the answerFor example, consider the Hamming distance between strings 110and 011•The xorof the two strings is:  which contains two 1bits•Therefore, the Hamming distance between 011and 101is 2Chapter 8268.9  The Hamming Distance Among Strings in a Codebook    Errors can transform a valid codeword into another valid codewordTo measure such transformations, we compute the Hamming distance between all pairs of codewordsin a given codebookConsider odd parity applied to 2-bitdatawordsFigure 8.6 lists the four (4)possible datawordsthe 4possible codewordsthat result from appending a parity bitand the Hamming distances for pairs of codewordsWe use to denote the minimum Hamming distance,dminamong pairs in a codebookThe concept gives an answer to the question aboveHow many bit errors can cause a transformation from one valid codeword into another valid codeword?Chapter 8278.9  The Hamming Distance Among Strings in a Codebook Chapter 8288.9  The Hamming Distance Among Strings in a Codebook    In the SPC example of Figure 8.6, the set consists of the Hamming distance between each pair of codewords, and dmin=2The definition means that there is at least one valid codeword that can be transformed into another valid codeword, if 2-bit errors occur during transmissionTo find the minimum number of bit changes that can transform a valid codeword into anther valid codeword, compute the minimum Hamming distance between all pairs in the codebook.Chapter 8298.10  The Tradeoff Between Error Detection and OverheadA large value of dminis desirable because the code is immune to more bit errors, if fewer than dminbits are changed, the code can detect that error(s) occurredEquation 8.1 specifies the relationship between dminand e, the maximum number of bit errors that can be detected:A code with a higher value of dminsends more redundant information than an error code with a lower value of dminCode rate (R) that gives the ratio of a datawordsize to the codeword size as shown in Equation 8.2Where k = size of actual data, n=size of datawordChapter 8308.11  Error Correction with Row and Column (RAC) Parity    Imagine an array of 3-rowsand 4-columns, with a parity bit added for each row and for each columnFigure 8.7 illustrates the arrangement, which is known as a Row and Column(RAC) code•Example RAC has n= 20, which means that it is a (20, 12)codeChapter 8318.11  Error Correction with Row and Column (RAC) Parity    How error correction works? Assume that one of the bits in Figure 8.7 (below) is changed during transmission:When the receiver arranges the bits into an array and parity bits are recalculated•two of the calculations will disagreewith the parity bits received, as Figure 8.8 illustrates•a single bit error will cause two calculated parity bits to disagree with the parity bit receivedChapter 832Example of RAC1  0  01  0  00  000011  0  01  0  01  10  1  101  0  01  11One error1  0  01  0  00  001  0  11  0  01  0  01  0  001  01  0  01  11Four errorsArrows indicate error checked bitsTwoerrors1  0  01  0  00  000011  0  01  0  01  0  01  101  0  01  11Three errors1  0  01  0  00  001  0  11  0  01  0  01  0  01  101  0  01  11Chapter 8338.11  Error Correction with Row and Column (RAC) Parity    The two disagreements correspond to the row and column position of the errorA receiver uses the calculated parity bits to determine exactly which bit is in error, and then corrects the bitThus, an RAC can correct any error that changes a single data bitWhat happens to an RAC code if an error changes more than one bit in a given block?RAC can only correct single-bit errorsIn cases where two or three bits are changed•an RAC encoding will be able to detect an odd number of errorsChapter 8348.12  The 16-Bit Checksum Used in the Internet      A particular coding scheme plays a key role in the InternetKnown as the Internet checksum, the code consists of a 16-bit 1s complement checksumThe Internet checksum does not impose a fixed size on a datawordthe algorithm allows a message to be arbitrarily longand computes a checksum over the entire messageThe Internet checksum treats data in a message as a series of 16-bit integers, as Figure 8.9 below illustratesChapter 8358.12  The 16-Bit Checksum Used in the Internet      To compute a checksum, a sender adds the numeric values of the 16-bit integersand it transmits the resultTo validate the message, a receiver performs the same computationAlgorithm 8.1 gives the details of the computationThe checksum is computed in 1s complement arithmetic and uses 16bit integers instead of 32or 64bit integersDuring the for loop, the addition may overflowThus, following the loop, the algorithm adds the overflow (the high-order bits) back into the sumWhy is a checksum computed as the arithmetic inverse of the sum instead of the sum?Chapter 8368.12  The 16-Bit Checksum Used in the Internet      Chapter 837Internet Checksum ExampleNoteWhen adding numbers, a carryout from the most significant bit needs to be added to the resultExample: add two 16-bit integers11  1  1  0  0  1  1  0  0  1  1  0  0  1  1  011  1  0  1  0  1  0  1  0  1  0  1  0  1  0  11  1  0  1  1  1  0  1  1  1  0  1  1  1  0  1  111  0  1  1  1  0  1  1  1  0  1  1  1  1  0  010  1  0  0  0  1  0  0  0  1  0  0  0  0  1  1wraparoundsumchecksumChapter 838An example of UDP checksumAssume you have two messages to send:MSG1: DEAD (1101 1110 1010 1101)MSG2: BEEF (1011 1110 1110 1111)Checksum value?1101111010101101+1011111011101111Sum+1100111011001110011001110110011101Checksum0110001001100010Senders put 0x6262 into checksum field and send it to IP datagram InvertedChapter 839An example of UDP checksumCheck on receiver side1101111010101101+10111110111011111001110110011101+ 01100010011000101111111111111111Good ! No errors in received message from sendersChecksumSum with carryChapter 840An example of UDP checksumWhat if 1 bit of only one MSG was changed ?Can we detect error bits ?DEAF(DEAD)1101111010101111+ BEEF1011111011101111Sum with carry1001110110011111+ Checksum01100010011000100000000000000001Error !!!Chapter 841An example of UDP checksumWhat if 1 bit of each MSG were changed ?Can we detect error bits ?DEAF(DEAD)1101111010101111+ BEED(BEEF)1011111011101101Sum with carry1001110110011101+ Checksum01100010011000101111111111111111No errors !Oops !!!Chapter 8428.13  Cyclic Redundancy Codes (CRC)    A form of channel coding known as a Cyclic Redundancy Code(CRC) is used in high-speed data networksKey properties of CRC are summarized belowChapter 8438.13  Cyclic Redundancy Codes (CRC)    Term cyclicis derived from a property of the codewords: A circular shiftof the bits of any codeword produces another oneFigure 8.11 (below) show a (7, 4) CRC by HammingChapter 8448.13  Cyclic Redundancy Codes (CRC)    CRC codes have been studied extensivelyA variety of mathematical explanations and computational techniques have been producedThe descriptions seem so disparate that it is difficult to understand how they can all refer to the same conceptPrincipal views include:Mathematicians explain a CRC computation as the remainder from a division of two polynomialswith binary coefficients•one representing the message and another representing a fixed divisorTheoretical Computer Scientists explain a CRC computation as the remainderfrom a division of two binary numbers•one representing the message and the other representing a fixed divisorChapter 8458.13  Cyclic Redundancy Codes (CRC)    Cryptographers explain a CRC computation as a mathematical operation in a Galois fieldof order 2, written GF(2)Computer programmers explain a CRC computation as an algorithm that iterates through a message and uses table lookup to obtain an additive value for each stepHardware architects explain a CRC computation as a small hardware pipeline unit that takes as input a sequence of bits from a message and produces a CRC without using division or iterationChapter 846478.13  Cyclic Redundancy Codes (CRC)    As an example of the views aboveconsider the division of binary numbers under the assumption of no carriesFigure 8.12 illustrates the division of 1010which represents a message, by a constant chosen for a specific CRC, 1011Chapter 8William Wesley PetersonEvaristeGalois478.13  Cyclic Redundancy Codes (CRC) Chapter 8488.13  Cyclic Redundancy Codes (CRC)    How can mathematicians view the above process as a polynomial division? think of each bit in a binary number as the coefficient of a term in a polynomialFor example, we can think of the divisor in Figure 8.12,  1011, as coefficients in the following polynomial:Similarly, the dividend in Figure 8.12, 1010000, represents the polynomial:Chapter 849508.13  Cyclic Redundancy Codes (CRC)    Term generator polynomial to describe a polynomial that corresponds to a divisorThe selection of a generator polynomial is key to creating a CRC with good error detection propertiesAn ideal polynomial is irreducible (i.e., can only be divided evenly by itself and 1)A polynomial with more than one non-zero coefficient can detect all single-bit errorsChapter 850Checksumming: Cyclic Redundancy Checkview data bits, D, as a binary numberchoose r+1 bit pattern (generator), Ggoal: choose r CRC bits, R, such that<D,R> exactly divisible by G (modulo 2) receiver knows G, divides <D,R> by G.  If non-zero remainder: error detected!can detect all burst errors less than r+1 bitswidely used in practice (ATM, HDCL)Chapter 851CRC ExampleWant:D.2rXOR R = nGequivalently:D.2r= nG XOR R equivalently:if we divide D.2rby G, want remainder RR = remainder[           ]D.2rGChapter 852CRC Example (transmit)Frame contents:111011Polynomial:11101 (x4+ x3+x2 + x0)Frame with 0s:111011000010000111101111011000011101-----1000011101-----1101Frame to send: 1110111101Chapter 853CRC Example (receive)Frame contents:1110111101Polynomial:11101 (x4+ x3+x2 + x0)10000111101111011110111101-----1110111101-----0Chapter 854Example of using CRCG=1101 (=X3+ X2+ 1), D=100010,  S = ? Chapter 855Example of using CRCG=1101 (=X3+ X2+ 1), D=100010,  S = ? R1101  10001000010111101110011010010000001000000100011011101111001101GS = 100010101Chapter 856Example of using CRCG=1101, D=100010, FCS(Frame Check Sequence)=101S = 100010101R=100010101G1101  100010101FCSR=1001101011101  100110101GFCSChapter 857Example of using CRCG=1101, D=100010, FCS(Frame Check Sequence)=101S = 100010101GR=1000101011101  100010101111001110110111101110011010011000001100000110111010000RFCSR=1001101011101  10011010111111011011001110110001101101111011100110111001101011RGFCSChapter 858Chapter 8Standard Polynomial (C)CRCCRC-8CRC-10CRC-12CRC-16CRC-CCITTCRC-32C(x)x8+x2+x1+1x10+x9+x5+x4+x1+1x12+x11+x3+x2+x1+1x16+x15+x2+1x16+x12+x5+1x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+159CRC PropertiesDetect all single-biterrors if coefficients of Xrand X0 of C(x) are oneDetect all double-biterrors, if C(x) has a factor with at least three termsDetect all number of odd errors, if C(x) contains factor (x+1)Detect all burst of errors smaller than r+1 bits (All consecutive bit errors of r bits or fewer will be detected)60Chapter 88.14  An Efficient Hardware Implementation of CRC    CRC hardware is arranged as a shift register with exclusive or (xor) gatesbetween some of the bitsFigure 8.13 illustrates the hardware needed for the 3-bit CRC computation from Figure 8.12Chapter 8618.15  Automatic Repeat reQuest(ARQ) MechanismsWhenever one side sends a message to another, the other side sends a short acknowledgement (ACK)message backFor example, if Asends a message to B, Bsends an ACK back to A Once it receives an ACK, Aknows that the message arrived correctlyIf no ACK is received after Ttime units, Aassumes the message was lost and retransmitsa copyARQ is especially useful in cases of dealing with detecting errorsbut not in cases for error correctionmany computer networks use a CRC to detect transmission errorsAn ARQ scheme can be added to guarantee delivery if a transmission error occursthe receiver discards the message if an error occursand the sender retransmits another copyChapter 862"

Chapter 8   Reliability and Channel CodingChapter 8This slide is adopted from LamiKaya& Douglas Comer1Topics Covered8.1  Introduction    8.2  The Three Main Sources of Transmission Errors    8.3  Effect of Transmission Errors on Data    8.4  Two Strategies for Handling Channel Errors    8.5  Block and ConvolutionalError Codes    8.6  An Example Block Error Code: Single Parity Checking    8.7  The Mathematics of Block Error Codes and (n, k) Notation    8.8  Hamming Distance: A Measure of a Code's Strength    8.9  The Hamming Distance Among Strings in a Codebook    8.10  The Tradeoff Between Error Detection and Overhead 8.11  Error Correction with Row and Column (RAC) Parity   8.12  The 16-Bit Checksum Used in the Internet      8.13  Cyclic Redundancy Codes (CRCs)    8.14  An Efficient Hardware Implementation of CRC    8.15  Automatic Repeat reQuest(ARQ) MechanismsChapter 828.1  Introduction    This chapter continues the discussion by examining errors that can occur during transmission and techniques that can be used to control errorsThe concepts presented here •are fundamental to computer networking•and are used in communication protocols at many layers of the stackChapter 83Interferenceelectromagnetic radiation emitted from devices such as electric motors and background cosmic radiation can cause noise that can disturb radio transmissions and signals traveling across wiresAttenuationAs a signal passes across a medium, the signal becomes weaker•signals on wires or optical fibers become weaker over long distances, just as a radio signal becomes weaker with distanceChapter 88.2  The Three Main Source of Transmission Errors   4DistortionAll physical systems distort signalsAs a pulse travels along an optical fiber, the pulse dispersesWires have properties of capacitanceand inductance•that block signals at some frequencies while admitting signals at other frequenciesPlacing a wire near a large metal object can change the set of frequencies that can pass through the wireMetal objects can block some frequencies of radio waves, while passing othersChapter 88.2  The Three Main Source of Transmission Errors   58.2  The Three Main Source of Transmission Errors   Shannon's Theorem suggests one way to reduce errors:increase the signal-to-noise ratio (either by increasing the signal or lowering noise if possible) where•Cis the effective limit on the channel capacity in bits per second•Bis the hardware bandwidth•S/Nis the  signal-to-noise ratio, the ratio of the average signal power divided by the average noise powerMechanisms like shieldedwiring can help lower noiseBut, Physical transmission system is always susceptible to errors•it may not be possible to change the signal-to-noise ratioChapter 868.2  The Three Main Source of Transmission Errors   Noise/interference cannot be eliminated completelyBut many transmission errors can be detectedIn some cases, errors can be correctedautomatically We will see that error detection adds overheadError handling is a tradeoff in which a system designer must decide whether a given error is likely to occur, and if so, what the consequences will beChapter 878.3  Effect of Transmission Errors on Data    Below table lists the three principal ways transmission errors affect dataChapter 8Type of ErrorDescriptionSingle Bit ErrorA single bitin a block of bits is changed and all other bits in the block are unchanged (often results from very short-duration interference)BurstErrorMultiple bits in a block of bits are changed (often results from longer-duration interference)Erasure (Ambiguity)The signalthat arrives at a receiver is ambiguous (does not clearly correspond to either a logical 1 or a logical 0 –can result from distortion or interference)88.3  Effect of Transmission Errors on Data    For a burst error, the burst size, orlength, is defined as the number of bits from the start of the corruption to the end of the corruptionFigure 8.2 illustrates the definitionChapter 898.4  Two Strategies for Handling Channel Errors    A variety of mathematical techniques have been developed that overcome errors during transmission and increase reliabilityKnown collectively as channel codingThe techniques can be divided into two broad categories:Forward Error Correction (FEC) mechanismsAutomatic Repeat reQuest(ARQ) mechanismsThe basic idea of FEC is straightforward: add additional information to data that allows a receiver toverify that data arrives correctly and to correct errors (if possible)Chapter 8108.4  Two Strategies for Handling Channel Errors Chapter 8118.4  Two Strategies for Handling Channel Errors    Basic error detection mechanisms allow a receiverto detect when an error has occurred; FEC (Forward Error Correction) mechanisms allow a receiver to determine exactly which bits have been changed and to compute correct valuesThe second approach to channel coding, known as an ARQ (Automatic Repeat reQuest),requires the cooperation of a sender;a sender and receiver exchange messagesto insure that all data arrives correctlyChapter 812AnFECcommunicationsystemaddsinformationatthe transmitterforerrorcorrectionofcorrupteddataatthe receiver.ATypicalErrorCorrectingCommunicationSystem.DataENCODEMODULATENoiseNoiseTRANSMITTERSECTIONINFORMATIONRECEIVERSECTIONDEMODULATEDECODEChapter 813ForwardErrorCorrection(FEC)Applications.Aspreviouslydiscussed,forwarderrorcorrectionisused atthereceivingendtodetecterrorsandcorrectforthem.SomeapplicationsincludeCDandDVDplayers,HDTV, Datastoragesystems,Wirelesscommunications,Satellite communications,andModemtechnologies.DesignershaveimplementedFECcircuitsinApplication SpecificIntegratedCircuits(ASICs),DigitalSignalProcessors (DSPs),andFieldProgrammableGateArrays(FPGAs).FECtechniquescanberealizedforbothBlockcodes andforConvolutionalcodesChapter 8148.5  Block and Convolutional Error Codes    The two types of FEC techniques satisfy separate needs:Block Error Codes•It divides the data to be sent into a set of blocks•It attaches extra information known asredundancy to each block•The encoding for a given block of bits depends only on the bits themselves, not on bits that were sent earlier•They are memory-less in the sense that the encoding mechanism does not carry state information from one block of data to the nextConvolutional Error Codes•It treats data as a series of bits, and computes a code over a continuous series•Thus, the code computed for a set of bits depends on the current input and some of the previous bits in the stream•Convolutional codes are said to be codes with memoryChapter 8158.6  An Example Block Error Code: Single Parity Checking    How can additional information be used to detect errors?consider a single parity checking (SPC) mechanismOne form of SPC defines a block to be an 8-bitunit of data (i.e., a single byte)•On the sending side, an encoder adds an extra bit, called a parity bit, to each byte before transmission•A receiver uses parity bit to check whether bits in the byte are correct•Before parity can be used, the sender and receiver must be configured for either even parity or odd parityFigure 8.4 lists examples of data bytes and the value of the parity bit that is sent when using even or odd parityChapter 8168.6  An Example Block Error Code: Single Parity Checking Chapter 8178.6  An Example Block Error Code: Single Parity Checking    SPC is a weak form of channel coding that can detect errorsbut cannot correct errorsAn even parity mechanism can only handle errors where an odd number of bits are changed•If one of the nine bits (including the parity bit) is changed during transmission, the receiver will declare that the incoming byte is invalid•However, if a burst error occurs in which two, four, six, or eightbits change value, the receiver will incorrectlyclassify the incoming byte as validChapter 818Example of Block Error CodeSingle Bit Parity:Detect single bit errorsTwo Dimensional Bit Parity (RAC):Detect and correctsingle bit errors0011Chapter 8198.7  The Mathematics of Block Error Codes and Notation    Mathematicallywe define the set of all possible messages to be a set of datawordsand define the set of all possible encoded versions to be a set of codewordsIf a datawordcontains kbits and r additional bits are added to form a codeword, we say that the result is an (n, k)encoding scheme where  n = k + rThe key to successful error detection lies in choosing a subset of the 2npossible combinations that are valid codewordsThe valid subset is known as a codebookChapter 8208.7 The Mathematics of Block Error Codes and NotationError DetectionExample •Let us assume that k = 2 and n = 3. The below table shows the list of data-words and code-words. Later, we will see how to derive a code-word from a data-word.DatawordCodewordDatawordCodeword000001010101011111101)If the receiver receives 011?Validcodeword and extract 012)If the receiver receives 111(the left most bit is corrupted)?Invalidcodeword and discard3)If the receiver receives 000? (the right two bits are corrupted)Validcodeword and extract 00 (detected ?)Assume the sender encodes the dataword “01” as “011” and send it to the receiverChapter 8218.7  The Mathematics of Block Error Codes and Notation    As an example, consider SPC(Single Parity Check)The set of datawordsconsists of any possible combination of 8-bits•Thus, k = 8 and there are 28or 256possible data words•The set of n = 9 bits, so there are 29or 512possibilities–However, only half of the 512 values form valid codewordsThink of the set of all possible n-bitvalues and the valid subset that forms the codebookIf an error occurs during transmission•one or more of the bits in a codeword will be changed, which will either produce another valid codeword or an invalid combinationFor the example discussed above•a change to a single bit of a valid codeword produces an invalid combination, but changing two bits produces another valid codewordChapter 8228.8 Hamming Distance: A Measure of a Code's Strength    No channel coding scheme is ideal!changing enough bits will always transform to a valid codewordWhat is the minimum number of bits of a valid codeword that must be changed to produce another valid codeword?To answer the question, engineers use a measure known as the  Hamming distance, named after a theorist at Bell Laboratories who was a pioneer in the field of information theory and channel codingGiven two strings of nbits each, the Hamming distance is defined as the number of differencesFigure 8.5 illustrates the definition ECC memory uses Hamming Codes Chapter 8238.8 Hamming Distance: A Measure of a Code's Strength Chapter 8248.8 Hamming DistanceHamming distance(d) of two bit strings = number of bit positions in which they differ.e.g.: d (000,011) = 2, (000 011) = 011 (two 1s)     d (10101,11110) = 3, (10101 11110) = 01011 (three 1s)000001111100101011110010codeworddmin= 2 = min distancen = 3 = dimensionality2n= 8 = number of nodesChapter 8258.8 Hamming Distance: A Measure of a Code's Strength    One way to compute the Hamming distance consists oftaking the exclusive or (xor) between two strings and counting the number of 1bits in the answerFor example, consider the Hamming distance between strings 110and 011•The xorof the two strings is:  which contains two 1bits•Therefore, the Hamming distance between 011and 101is 2Chapter 8268.9  The Hamming Distance Among Strings in a Codebook    Errors can transform a valid codeword into another valid codewordTo measure such transformations, we compute the Hamming distance between all pairs of codewordsin a given codebookConsider odd parity applied to 2-bitdatawordsFigure 8.6 lists the four (4)possible datawordsthe 4possible codewordsthat result from appending a parity bitand the Hamming distances for pairs of codewordsWe use to denote the minimum Hamming distance,dminamong pairs in a codebookThe concept gives an answer to the question aboveHow many bit errors can cause a transformation from one valid codeword into another valid codeword?Chapter 8278.9  The Hamming Distance Among Strings in a Codebook Chapter 8288.9  The Hamming Distance Among Strings in a Codebook    In the SPC example of Figure 8.6, the set consists of the Hamming distance between each pair of codewords, and dmin=2The definition means that there is at least one valid codeword that can be transformed into another valid codeword, if 2-bit errors occur during transmissionTo find the minimum number of bit changes that can transform a valid codeword into anther valid codeword, compute the minimum Hamming distance between all pairs in the codebook.Chapter 8298.10  The Tradeoff Between Error Detection and OverheadA large value of dminis desirable because the code is immune to more bit errors, if fewer than dminbits are changed, the code can detect that error(s) occurredEquation 8.1 specifies the relationship between dminand e, the maximum number of bit errors that can be detected:A code with a higher value of dminsends more redundant information than an error code with a lower value of dminCode rate (R) that gives the ratio of a datawordsize to the codeword size as shown in Equation 8.2Where k = size of actual data, n=size of datawordChapter 8308.11  Error Correction with Row and Column (RAC) Parity    Imagine an array of 3-rowsand 4-columns, with a parity bit added for each row and for each columnFigure 8.7 illustrates the arrangement, which is known as a Row and Column(RAC) code•Example RAC has n= 20, which means that it is a (20, 12)codeChapter 8318.11  Error Correction with Row and Column (RAC) Parity    How error correction works? Assume that one of the bits in Figure 8.7 (below) is changed during transmission:When the receiver arranges the bits into an array and parity bits are recalculated•two of the calculations will disagreewith the parity bits received, as Figure 8.8 illustrates•a single bit error will cause two calculated parity bits to disagree with the parity bit receivedChapter 832Example of RAC1  0  01  0  00  000011  0  01  0  01  10  1  101  0  01  11One error1  0  01  0  00  001  0  11  0  01  0  01  0  001  01  0  01  11Four errorsArrows indicate error checked bitsTwoerrors1  0  01  0  00  000011  0  01  0  01  0  01  101  0  01  11Three errors1  0  01  0  00  001  0  11  0  01  0  01  0  01  101  0  01  11Chapter 8338.11  Error Correction with Row and Column (RAC) Parity    The two disagreements correspond to the row and column position of the errorA receiver uses the calculated parity bits to determine exactly which bit is in error, and then corrects the bitThus, an RAC can correct any error that changes a single data bitWhat happens to an RAC code if an error changes more than one bit in a given block?RAC can only correct single-bit errorsIn cases where two or three bits are changed•an RAC encoding will be able to detect an odd number of errorsChapter 8348.12  The 16-Bit Checksum Used in the Internet      A particular coding scheme plays a key role in the InternetKnown as the Internet checksum, the code consists of a 16-bit 1s complement checksumThe Internet checksum does not impose a fixed size on a datawordthe algorithm allows a message to be arbitrarily longand computes a checksum over the entire messageThe Internet checksum treats data in a message as a series of 16-bit integers, as Figure 8.9 below illustratesChapter 8358.12  The 16-Bit Checksum Used in the Internet      To compute a checksum, a sender adds the numeric values of the 16-bit integersand it transmits the resultTo validate the message, a receiver performs the same computationAlgorithm 8.1 gives the details of the computationThe checksum is computed in 1s complement arithmetic and uses 16bit integers instead of 32or 64bit integersDuring the for loop, the addition may overflowThus, following the loop, the algorithm adds the overflow (the high-order bits) back into the sumWhy is a checksum computed as the arithmetic inverse of the sum instead of the sum?Chapter 8368.12  The 16-Bit Checksum Used in the Internet      Chapter 837Internet Checksum ExampleNoteWhen adding numbers, a carryout from the most significant bit needs to be added to the resultExample: add two 16-bit integers11  1  1  0  0  1  1  0  0  1  1  0  0  1  1  011  1  0  1  0  1  0  1  0  1  0  1  0  1  0  11  1  0  1  1  1  0  1  1  1  0  1  1  1  0  1  111  0  1  1  1  0  1  1  1  0  1  1  1  1  0  010  1  0  0  0  1  0  0  0  1  0  0  0  0  1  1wraparoundsumchecksumChapter 838An example of UDP checksumAssume you have two messages to send:MSG1: DEAD (1101 1110 1010 1101)MSG2: BEEF (1011 1110 1110 1111)Checksum value?1101111010101101+1011111011101111Sum+1100111011001110011001110110011101Checksum0110001001100010Senders put 0x6262 into checksum field and send it to IP datagram InvertedChapter 839An example of UDP checksumCheck on receiver side1101111010101101+10111110111011111001110110011101+ 01100010011000101111111111111111Good ! No errors in received message from sendersChecksumSum with carryChapter 840An example of UDP checksumWhat if 1 bit of only one MSG was changed ?Can we detect error bits ?DEAF(DEAD)1101111010101111+ BEEF1011111011101111Sum with carry1001110110011111+ Checksum01100010011000100000000000000001Error !!!Chapter 841An example of UDP checksumWhat if 1 bit of each MSG were changed ?Can we detect error bits ?DEAF(DEAD)1101111010101111+ BEED(BEEF)1011111011101101Sum with carry1001110110011101+ Checksum01100010011000101111111111111111No errors !Oops !!!Chapter 8428.13  Cyclic Redundancy Codes (CRC)    A form of channel coding known as a Cyclic Redundancy Code(CRC) is used in high-speed data networksKey properties of CRC are summarized belowChapter 8438.13  Cyclic Redundancy Codes (CRC)    Term cyclicis derived from a property of the codewords: A circular shiftof the bits of any codeword produces another oneFigure 8.11 (below) show a (7, 4) CRC by HammingChapter 8448.13  Cyclic Redundancy Codes (CRC)    CRC codes have been studied extensivelyA variety of mathematical explanations and computational techniques have been producedThe descriptions seem so disparate that it is difficult to understand how they can all refer to the same conceptPrincipal views include:Mathematicians explain a CRC computation as the remainder from a division of two polynomialswith binary coefficients•one representing the message and another representing a fixed divisorTheoretical Computer Scientists explain a CRC computation as the remainderfrom a division of two binary numbers•one representing the message and the other representing a fixed divisorChapter 8458.13  Cyclic Redundancy Codes (CRC)    Cryptographers explain a CRC computation as a mathematical operation in a Galois fieldof order 2, written GF(2)Computer programmers explain a CRC computation as an algorithm that iterates through a message and uses table lookup to obtain an additive value for each stepHardware architects explain a CRC computation as a small hardware pipeline unit that takes as input a sequence of bits from a message and produces a CRC without using division or iterationChapter 846478.13  Cyclic Redundancy Codes (CRC)    As an example of the views aboveconsider the division of binary numbers under the assumption of no carriesFigure 8.12 illustrates the division of 1010which represents a message, by a constant chosen for a specific CRC, 1011Chapter 8William Wesley PetersonEvaristeGalois478.13  Cyclic Redundancy Codes (CRC) Chapter 8488.13  Cyclic Redundancy Codes (CRC)    How can mathematicians view the above process as a polynomial division? think of each bit in a binary number as the coefficient of a term in a polynomialFor example, we can think of the divisor in Figure 8.12,  1011, as coefficients in the following polynomial:Similarly, the dividend in Figure 8.12, 1010000, represents the polynomial:Chapter 849508.13  Cyclic Redundancy Codes (CRC)    Term generator polynomial to describe a polynomial that corresponds to a divisorThe selection of a generator polynomial is key to creating a CRC with good error detection propertiesAn ideal polynomial is irreducible (i.e., can only be divided evenly by itself and 1)A polynomial with more than one non-zero coefficient can detect all single-bit errorsChapter 850Checksumming: Cyclic Redundancy Checkview data bits, D, as a binary numberchoose r+1 bit pattern (generator), Ggoal: choose r CRC bits, R, such that<D,R> exactly divisible by G (modulo 2) receiver knows G, divides <D,R> by G.  If non-zero remainder: error detected!can detect all burst errors less than r+1 bitswidely used in practice (ATM, HDCL)Chapter 851CRC ExampleWant:D.2rXOR R = nGequivalently:D.2r= nG XOR R equivalently:if we divide D.2rby G, want remainder RR = remainder[           ]D.2rGChapter 852CRC Example (transmit)Frame contents:111011Polynomial:11101 (x4+ x3+x2 + x0)Frame with 0s:111011000010000111101111011000011101-----1000011101-----1101Frame to send: 1110111101Chapter 853CRC Example (receive)Frame contents:1110111101Polynomial:11101 (x4+ x3+x2 + x0)10000111101111011110111101-----1110111101-----0Chapter 854Example of using CRCG=1101 (=X3+ X2+ 1), D=100010,  S = ? Chapter 855Example of using CRCG=1101 (=X3+ X2+ 1), D=100010,  S = ? R1101  10001000010111101110011010010000001000000100011011101111001101GS = 100010101Chapter 856Example of using CRCG=1101, D=100010, FCS(Frame Check Sequence)=101S = 100010101R=100010101G1101  100010101FCSR=1001101011101  100110101GFCSChapter 857Example of using CRCG=1101, D=100010, FCS(Frame Check Sequence)=101S = 100010101GR=1000101011101  100010101111001110110111101110011010011000001100000110111010000RFCSR=1001101011101  10011010111111011011001110110001101101111011100110111001101011RGFCSChapter 858Chapter 8Standard Polynomial (C)CRCCRC-8CRC-10CRC-12CRC-16CRC-CCITTCRC-32C(x)x8+x2+x1+1x10+x9+x5+x4+x1+1x12+x11+x3+x2+x1+1x16+x15+x2+1x16+x12+x5+1x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+159CRC PropertiesDetect all single-biterrors if coefficients of Xrand X0 of C(x) are oneDetect all double-biterrors, if C(x) has a factor with at least three termsDetect all number of odd errors, if C(x) contains factor (x+1)Detect all burst of errors smaller than r+1 bits (All consecutive bit errors of r bits or fewer will be detected)60Chapter 88.14  An Efficient Hardware Implementation of CRC    CRC hardware is arranged as a shift register with exclusive or (xor) gatesbetween some of the bitsFigure 8.13 illustrates the hardware needed for the 3-bit CRC computation from Figure 8.12Chapter 8618.15  Automatic Repeat reQuest(ARQ) MechanismsWhenever one side sends a message to another, the other side sends a short acknowledgement (ACK)message backFor example, if Asends a message to B, Bsends an ACK back to A Once it receives an ACK, Aknows that the message arrived correctlyIf no ACK is received after Ttime units, Aassumes the message was lost and retransmitsa copyARQ is especially useful in cases of dealing with detecting errorsbut not in cases for error correctionmany computer networks use a CRC to detect transmission errorsAn ARQ scheme can be added to guarantee delivery if a transmission error occursthe receiver discards the message if an error occursand the sender retransmits another copyChapter 862